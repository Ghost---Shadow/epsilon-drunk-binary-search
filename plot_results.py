#!/usr/bin/env python3
"""
Plotting script for Epsilon Drunk Binary Search results.

This script reads the CSV results generated by main.py and creates visualizations.
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import argparse
import sys
from pathlib import Path
import os


def create_comparison_plot(df_scenario, scenario_name, filename):
    """Create the main comparison plot showing average comparisons vs epsilon."""
    # Ensure plots directory exists
    os.makedirs("./plots", exist_ok=True)
    
    # Sort by epsilon for proper plotting
    df_sorted = df_scenario.sort_values('epsilon')
    epsilons = df_sorted['epsilon'].values
    avg_comps = df_sorted['avg_comparisons'].values
    ci_lowers = df_sorted['ci_lower'].values
    ci_uppers = df_sorted['ci_upper'].values
    regular_avg = df_sorted['regular_avg'].iloc[0]
    
    # Get array info for title
    array_drunkness = df_sorted['array_gini_coefficient'].iloc[0]
    # No longer using clustered vs jagged distinction
    total_trials = df_sorted['total_trials'].iloc[0]
    
    if array_drunkness > 0:
        array_desc = f"Array (Gini={array_drunkness:.3f})"
    else:
        array_desc = "Sober Evenly-Spaced Array"
    
    # Find the optimal point
    best_idx = np.argmin(avg_comps)
    best_eps = epsilons[best_idx]
    best_comps = avg_comps[best_idx]
    
    # Create plot
    fig, ax = plt.subplots(1, 1, figsize=(10, 10))
    ax.plot(
        epsilons,
        avg_comps,
        "b-o",
        linewidth=3,
        markersize=6,
        label="Average Performance",
    )
    ax.fill_between(
        epsilons,
        ci_lowers,
        ci_uppers,
        alpha=0.3,
        color="blue",
        label="95% Confidence Interval",
    )
    ax.axhline(
        y=regular_avg,
        color="r",
        linestyle="--",
        linewidth=2,
        label="Regular Binary Search",
    )
    ax.plot(
        best_eps,
        best_comps,
        "go",
        markersize=15,
        label=f"Peak: Œµ={best_eps:.3f}",
        markeredgecolor="darkgreen",
        markeredgewidth=2,
    )
    
    ax.set_xlabel("Epsilon (positive = overshoot, negative = undershoot)", fontsize=14)
    ax.set_ylabel("Average Comparisons", fontsize=14)
    ax.set_title(
        f'üç∫ Balmer Peak: {array_desc}\n(n={total_trials} trials)',
        fontsize=16,
        pad=20,
    )
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=12)
    ax.tick_params(labelsize=12)
    
    plt.tight_layout()
    plt.savefig(filename, dpi=300, bbox_inches="tight")
    print(f"üìä Comparisons plot saved as '{filename}'")
    plt.close()


def create_improvement_plot(df_scenario, scenario_name, filename):
    """Create the improvement percentage plot."""
    # Ensure plots directory exists
    os.makedirs("./plots", exist_ok=True)
    
    # Sort by epsilon for proper plotting
    df_sorted = df_scenario.sort_values('epsilon')
    epsilons = df_sorted['epsilon'].values
    improvements = df_sorted['improvement_pct'].values
    is_significant = df_sorted['is_significant'].values
    
    # Get array info for title
    array_drunkness = df_sorted['array_gini_coefficient'].iloc[0]
    # No longer using clustered vs jagged distinction
    
    if array_drunkness > 0:
        array_desc = f"Array (Gini={array_drunkness:.3f})"
    else:
        array_desc = "Sober Evenly-Spaced Array"
    
    # Create plot
    fig, ax = plt.subplots(1, 1, figsize=(10, 10))
    ax.plot(
        epsilons,
        improvements,
        "g-o",
        linewidth=3,
        markersize=6,
        label="Performance Change",
    )
    ax.axhline(y=0, color="r", linestyle="--", linewidth=2, label="No Improvement")
    
    # Mark statistically significant points
    significant_mask = is_significant
    if significant_mask.any():
        ax.scatter(
            epsilons[significant_mask],
            improvements[significant_mask],
            color="red",
            s=100,
            marker="*",
            label="Statistically Significant",
            zorder=5,
            edgecolors="darkred",
            linewidths=1,
        )
    
    ax.set_xlabel("Epsilon (positive = overshoot, negative = undershoot)", fontsize=14)
    ax.set_ylabel("Improvement over Regular Binary Search (%)", fontsize=14)
    ax.set_title(
        f"üìà Performance Improvement: {array_desc}\n(* = p < 0.05)", fontsize=16, pad=20
    )
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=12)
    ax.tick_params(labelsize=12)
    
    plt.tight_layout()
    plt.savefig(filename, dpi=300, bbox_inches="tight")
    print(f"üìä Improvement plot saved as '{filename}'")
    plt.close()


def create_drunkness_plot(df_scenario, scenario_name, filename):
    """Create the drunkness level plot."""
    # Ensure plots directory exists
    os.makedirs("./plots", exist_ok=True)
    
    # Sort by epsilon for proper plotting
    df_sorted = df_scenario.sort_values('epsilon')
    epsilons = df_sorted['epsilon'].values
    avg_comps = df_sorted['avg_comparisons'].values
    regular_avg = df_sorted['regular_avg'].iloc[0]
    
    # Get array info for title
    array_drunkness = df_sorted['array_gini_coefficient'].iloc[0]
    # No longer using clustered vs jagged distinction
    
    if array_drunkness > 0:
        array_desc = f"Array (Gini={array_drunkness:.3f})"
    else:
        array_desc = "Sober Evenly-Spaced Array"
    
    # Find the optimal point
    best_idx = np.argmin(avg_comps)
    best_eps = epsilons[best_idx]
    best_comps = avg_comps[best_idx]
    best_drunkness = abs(best_eps)
    
    # Create plot vs absolute epsilon (drunkness level)
    abs_epsilons = np.abs(epsilons)
    fig, ax = plt.subplots(1, 1, figsize=(10, 10))
    ax.plot(
        abs_epsilons,
        avg_comps,
        "purple",
        marker="o",
        linewidth=3,
        markersize=6,
        label="Search Performance",
    )
    ax.axhline(
        y=regular_avg,
        color="r",
        linestyle="--",
        linewidth=2,
        label="Regular Binary Search (Sober)",
    )
    ax.plot(
        best_drunkness,
        best_comps,
        "go",
        markersize=15,
        label=f"Optimal Search Drunkness: |Œµ|={best_drunkness:.3f}",
        markeredgecolor="darkgreen",
        markeredgewidth=2,
    )
    
    ax.set_xlabel("|Epsilon| (Search Algorithm Drunkness Level)", fontsize=14)
    ax.set_ylabel("Average Comparisons", fontsize=14)
    ax.set_title(
        f"ü•¥ Performance vs Search Drunkness: {array_desc}", fontsize=16, pad=20
    )
    ax.grid(True, alpha=0.3)
    ax.legend(fontsize=12)
    ax.tick_params(labelsize=12)
    
    plt.tight_layout()
    plt.savefig(filename, dpi=300, bbox_inches="tight")
    print(f"üìä Drunkness plot saved as '{filename}'")
    plt.close()


def create_correlation_plot(df, filename="array_vs_method_drunkness_correlation.png"):
    """Create a comprehensive heatmap showing all array Gini vs epsilon combinations."""
    
    # Create plots directory if it doesn't exist
    os.makedirs("./plots", exist_ok=True)
    filename = f"./plots/{filename}"
    
    fig, ax = plt.subplots(1, 1, figsize=(16, 10))
    
    # Create a pivot table for the full heatmap
    # Use all combinations, not just optimal ones
    pivot_table = df.pivot_table(
        values='avg_comparisons', 
        index='drunkness_level',  # epsilon (y-axis)
        columns='array_gini_coefficient',  # gini (x-axis)
        aggfunc='mean'
    )
    
    # Create the heatmap
    im = ax.imshow(pivot_table.values, cmap='viridis', aspect='auto', origin='lower')
    
    # Set ticks and labels
    ax.set_xticks(range(len(pivot_table.columns)))
    ax.set_xticklabels([f'{g:.3f}' for g in pivot_table.columns])
    ax.set_yticks(range(len(pivot_table.index)))
    ax.set_yticklabels([f'{e:.3f}' for e in pivot_table.index])
    
    # Add colorbar
    cbar = plt.colorbar(im, ax=ax)
    cbar.set_label('Average Comparisons', fontsize=12)
    
    # Add text annotations with performance values
    for i in range(len(pivot_table.index)):
        for j in range(len(pivot_table.columns)):
            perf_val = pivot_table.iloc[i, j]
            if not np.isnan(perf_val):
                ax.text(j, i, f'{perf_val:.2f}', 
                       ha='center', va='center', fontsize=8, 
                       color='white' if perf_val < pivot_table.values.mean() else 'black',
                       weight='bold')
    
    # Set labels and title
    ax.set_xlabel('Array Drunkness (Gini Coefficient)', fontsize=14)
    ax.set_ylabel('Search Method Drunkness Level (|Œµ|)', fontsize=14)
    ax.set_title('üç∫ Full Grid Search Heatmap: Array Drunkness vs Search Method Drunkness\n(All Combinations)', fontsize=16, pad=20)
    
    # Calculate correlation using all valid data points
    gini_values = []
    epsilon_values = []
    performance_values = []
    
    for i, eps in enumerate(pivot_table.index):
        for j, gini in enumerate(pivot_table.columns):
            perf = pivot_table.iloc[i, j]
            if not np.isnan(perf):
                gini_values.append(gini)
                epsilon_values.append(abs(eps))  # Use absolute epsilon for drunkness level
                performance_values.append(perf)
    
    if len(gini_values) > 1:
        correlation = np.corrcoef(gini_values, epsilon_values)[0, 1]
        
        # Add statistics box
        stats_text = f'Correlation: r = {correlation:.3f}\nTotal Combinations: {len(gini_values)}\nGini Levels: {len(pivot_table.columns)}\nEpsilon Levels: {len(pivot_table.index)}'
        ax.text(0.02, 0.98, stats_text, transform=ax.transAxes, fontsize=11, 
                bbox=dict(boxstyle='round', facecolor='white', alpha=0.9),
                verticalalignment='top')
    
    plt.tight_layout()
    plt.savefig(filename, dpi=300, bbox_inches="tight")
    print(f"üìä Full correlation heatmap saved as '{filename}'")
    plt.close()


def create_all_plots_for_scenario(df_scenario, scenario_name):
    """Create all three plots for a scenario."""
    # Create plots directory if it doesn't exist
    os.makedirs("./plots", exist_ok=True)
    
    filename_prefix = f'./plots/balmer_peak_{scenario_name.lower().replace(" ", "_")}'
    
    create_comparison_plot(df_scenario, scenario_name, f"{filename_prefix}_comparisons.png")
    create_improvement_plot(df_scenario, scenario_name, f"{filename_prefix}_improvement.png")
    create_drunkness_plot(df_scenario, scenario_name, f"{filename_prefix}_drunkness.png")


def create_summary_plot(df, filename="epsilon_drunk_search_summary.png"):
    """Create a summary plot comparing all scenarios."""
    # Create plots directory if it doesn't exist
    os.makedirs("./plots", exist_ok=True)
    filename = f"./plots/{filename}"
    
    scenarios = df['scenario_name'].unique()
    
    fig, axes = plt.subplots(2, 3, figsize=(18, 12))
    axes = axes.flatten()
    
    for i, scenario in enumerate(scenarios):
        if i >= len(axes):
            break
            
        df_scenario = df[df['scenario_name'] == scenario].sort_values('epsilon')
        
        ax = axes[i]
        epsilons = df_scenario['epsilon'].values
        avg_comps = df_scenario['avg_comparisons'].values
        regular_avg = df_scenario['regular_avg'].iloc[0]
        
        ax.plot(epsilons, avg_comps, "b-o", linewidth=2, markersize=4)
        ax.axhline(y=regular_avg, color="r", linestyle="--", linewidth=1)
        ax.set_title(scenario, fontsize=12)
        ax.set_xlabel("Epsilon", fontsize=10)
        ax.set_ylabel("Avg Comparisons", fontsize=10)
        ax.grid(True, alpha=0.3)
        ax.tick_params(labelsize=8)
    
    # Hide unused subplots
    for i in range(len(scenarios), len(axes)):
        axes[i].set_visible(False)
    
    plt.suptitle("üç∫ Epsilon Drunk Binary Search - All Scenarios", fontsize=16)
    plt.tight_layout()
    plt.savefig(filename, dpi=300, bbox_inches="tight")
    print(f"üìä Summary plot saved as '{filename}'")
    plt.close()


def main():
    parser = argparse.ArgumentParser(description="Generate plots from epsilon drunk search results")
    parser.add_argument(
        "--csv", 
        default="epsilon_drunk_search_results.csv",
        help="CSV file with results (default: epsilon_drunk_search_results.csv)"
    )
    parser.add_argument(
        "--scenario", 
        help="Generate plots for specific scenario only"
    )
    parser.add_argument(
        "--summary-only", 
        action="store_true",
        help="Generate only the summary plot"
    )
    
    args = parser.parse_args()
    
    # Check if CSV file exists
    if not Path(args.csv).exists():
        print(f"‚ùå Error: CSV file '{args.csv}' not found!")
        print("Run 'python main.py' first to generate the results.")
        sys.exit(1)
    
    # Read the CSV data
    try:
        df = pd.read_csv(args.csv)
        print(f"üìñ Loaded data from '{args.csv}'")
        print(f"Found {len(df)} rows across {len(df['scenario_name'].unique())} scenarios")
    except Exception as e:
        print(f"‚ùå Error reading CSV file: {e}")
        sys.exit(1)
    
    if args.summary_only:
        create_summary_plot(df)
    elif args.scenario:
        # Generate plots for specific scenario
        if args.scenario not in df['scenario_name'].unique():
            print(f"‚ùå Error: Scenario '{args.scenario}' not found!")
            print(f"Available scenarios: {list(df['scenario_name'].unique())}")
            sys.exit(1)
        
        df_scenario = df[df['scenario_name'] == args.scenario]
        create_all_plots_for_scenario(df_scenario, args.scenario)
    else:
        # Generate all plots
        scenarios = df['scenario_name'].unique()
        print(f"üìä Generating plots for {len(scenarios)} scenarios...")
        
        for scenario in scenarios:
            print(f"\\nüé® Creating plots for: {scenario}")
            df_scenario = df[df['scenario_name'] == scenario]
            create_all_plots_for_scenario(df_scenario, scenario)
        
        # Also create summary plot
        print("\\nüé® Creating summary plot...")
        create_summary_plot(df)
        
        # Create correlation plot
        print("\\nüé® Creating correlation plot...")
        create_correlation_plot(df)
    
    print("\\nüéâ Plot generation complete!")


if __name__ == "__main__":
    main()